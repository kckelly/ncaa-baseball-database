"""
File containing helper methods for contacting the postgres database.
"""
import os
import sys

import psycopg2
import unicodecsv

import FileUtils


def connect():
    """
    Connect to the database and return the connection generated by psycopg2.
    
    :return: the connection
    """
    try:
        connection = psycopg2.connect(user=os.getenv('NCAABaseballUser'),
                                      password=os.getenv('NCAABaseballPassword'),
                                      host='localhost',
                                      port=5432,
                                      database='ncaa_baseball')
        return connection
    except psycopg2.Error as error:
        print("Error while connecting to ncaa_baseball, make sure your environment variables are "
              "set properly", error)
        sys.exit(1)


def get_year_info(year):
    """
    Get the ids for the year specified.
    
    :param year: the year to get the ids of
    :return: a dict containing the year_id, hitting_id, pitching_id, and fielding_id for that year
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT year_id, hitting_id, pitching_id, fielding_id '
                   'FROM year_info '
                   'WHERE year={year}'.format(year=year))
    ids = list(cursor.fetchone())
    connection.close()
    return {'year_id': ids[0], 'hitting_id': ids[1], 'pitching_id': ids[2], 'fielding_id': ids[3]}


def get_default_conference_id():
    """
    Get the id of the default conference from the conference table.
    :return: the id of the default conference
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id '
                   'FROM conference '
                   'WHERE conference.name = \'{conference_name}\';'.format(conference_name='Other'))
    conference_id = cursor.fetchone()[0]
    connection.close()
    return conference_id


def get_all_conferences():
    """
    Get all conferences from the database.
    
    :return: a list of conference dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, name, division '
                   'FROM conference;')
    conferences = []
    for row in cursor:
        conferences.append({'id': row[0], 'name': row[1], 'division': row[2]})
    connection.close()
    return conferences


def get_all_schools():
    """
    Get all schools from the database.

    :return: a list of school dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, ncaa_id, name, nickname, url '
                   'FROM school;')
    schools = []
    for row in cursor:
        schools.append({'id': row[0], 'ncaa_id': row[1], 'name': row[2], 'nickname': row[3],
                        'url': row[4]})
    connection.close()
    return schools


def get_all_stadiums():
    """
    Get all stadiums from the database.
    :return: a list of stadium dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, name '
                   'FROM stadium;')
    stadiums = []
    for row in cursor:
        stadiums.append({'id': row[0], 'name': row[1]})
    connection.close()
    return stadiums


def get_all_coaches():
    """
    Get all coaches from the database.
    :return: a list of coach dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, ncaa_id, first_name, last_name '
                   'FROM coach;')
    coaches = []
    for row in cursor:
        coaches.append({'id': row[0], 'ncaa_id': row[1], 'first_name': row[2], 'last_name': row[3]})
    connection.close()
    return coaches


def get_all_teams():
    """
    Get all teams from the database.
    :return: a list of team dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, year, conference_id, school_id, coach_id, stadium_id '
                   'FROM team;')
    teams = []
    for row in cursor:
        teams.append({'id': row[0], 'year': row[1], 'conference_id': row[2],
                      'school_id': row[3],
                      'coach_id': row[4], 'stadium_id': row[4]})
    connection.close()
    return teams


def get_all_team_info():
    """
    Gets all team information from the database, including conference info, school info,
    coach info, and stadium info.
    :return: a list of team information dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT team.id, team.year, '
                   '       conference.id, conference.name, conference.division, '
                   '       school.id, school.ncaa_id, school.name, school.nickname, school.url, '
                   '       coach.id, coach.ncaa_id, coach.first_name, coach.last_name, '
                   '           coach.alma_mater, coach.year_graduated, '
                   '       stadium.id, stadium.name, stadium.capacity, stadium.year_built '
                   'FROM team '
                   '    JOIN conference ON team.conference_id = conference.id '
                   '    JOIN school ON team.school_id = school.id '
                   '    LEFT JOIN coach ON team.coach_id = coach.id '
                   '    LEFT JOIN stadium ON team.stadium_id = stadium.id;')
    teams = []
    for row in cursor:
        teams.append({'team_id': row[0], 'year': row[1],
                      'conference_id': row[2], 'conference_name': row[3], 'division': row[4],
                      'school_id': row[5], 'school_ncaa_id': row[6],
                      'school_name': row[7],
                      'school_nickname': row[8], 'school_url': row[9],
                      'coach_id': row[10], 'coach_ncaa_id': row[11],
                      'coach_first_name': row[12],
                      'coach_last_name': row[11], 'coach_alma_mater': row[12],
                      'coach_year_graduated': row[13],
                      'stadium_id': row[14], 'stadium_name': row[15],
                      'stadium_capacity': row[16],
                      'stadium_year_built': row[17]})
    connection.close()
    return teams


def get_all_players():
    """
    Get all players from the database.
    :return: a list of player dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, ncaa_id, first_name, last_name '
                   'FROM player;')
    players = []
    for row in cursor:
        players.append({'player_id': row[0], 'ncaa_id': row[1], 'first_name': row[2],
                        'last_name': row[3]})
    connection.close()
    return players


def get_all_roster_info():
    """
    Get all roster information from the database, joins the player table.
    :return: A list of roster dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT roster.id, roster.team_id, roster.player_id, roster.class, '
                   'player.ncaa_id, player.first_name, player.last_name, team.year '
                   'FROM roster '
                   '    JOIN player ON roster.player_id = player.id '
                   '    JOIN team ON roster.team_id = team.id;')
    roster_rows = []
    for row in cursor:
        roster_rows.append({'roster_id': row[0], 'team_id': row[1], 'player_id': row[2],
                            'class': row[3], 'ncaa_id': row[4], 'first_name': row[5],
                            'last_name': row[6], 'year': row[7]})
    connection.close()
    return roster_rows


def get_all_game_info():
    """
    Get all games in the game table.
    :return: a list of game dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, ncaa_id, away_team_id, home_team_id, date, location, attendance '
                   'FROM game;')
    games = []
    for row in cursor:
        games.append({'id': row[0], 'ncaa_id': row[1], 'away_team_id': row[2], 'home_team_id':
            row[3], 'date': row[4], 'location': row[5], 'attendance': row[6]})
    connection.close()
    return games


def get_all_innings():
    """
    Get all inning run totals in the database.
    :return: a list of inning dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game_id, team_id, inning, runs '
                   'FROM inning')
    innings = []
    for row in cursor:
        innings.append({'game_id': row[0], 'team_id': row[1], 'inning': row[2], 'runs': row[3]})
    connection.close()
    return innings


def get_all_game_position_info():
    """
    Get all game position relations from the game_position table.
    :return: a list of game position dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game_id, roster_id, position '
                   'FROM game_position;')
    game_positions = []
    for row in cursor:
        game_positions.append({'game_id': row[0], 'roster_id': row[1], 'position': row[2]})
    connection.close()
    return game_positions


def get_all_box_score_lines(stat_type):
    """
    Get all box score lines from the stat_type_line table of this stat type.
    :param stat_type: the stat type of this table (hitting, pitching, or fielding)
    :return: a list of box score line lists with game_id and roster_id in positions 0 and 1
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT * '
                   'FROM {stat_type}_line'.format(stat_type=stat_type))
    box_score_lines = []
    for row in cursor:
        box_score_lines.append(row)
    connection.close()
    return box_score_lines


def get_all_umpires():
    """
    Get all umpires from the database.
    :return: a list of umpire dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id, first_name, last_name '
                   'FROM umpire;')
    umpires = []
    for row in cursor:
        umpires.append({'id': row[0], 'first_name': row[1], 'last_name': row[2]})
    connection.close()
    return umpires


def get_all_game_umpires():
    """
    Get all game umpire relations from the database.
    :return: a dict of game ids to a dict of umpire ids corresponding to hp, 1b, 2b, 3b, lf, and rf
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game_id, umpire_id, position '
                   'FROM game_umpire;')
    
    game_umpires = {}
    for row in cursor:
        if row[0] not in game_umpires:
            game_umpires.update({row[0]: {'hp': None, '1b': None, '2b': None, '3b': None,
                                          'lf': None, 'rf': None}})
        game_umpires[row[0]][row[2]] = row[1]
    
    connection.close()
    return game_umpires


def get_all_play_by_play():
    """
    Get all play by play text and information from the database.
    :return: a list of play by play dicts
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game_id, team_id, inning, side, ord, text, pitches '
                   'FROM play_by_play;')
    pbp = []
    for row in cursor:
        pbp.append({'game_id': row[0], 'team_id': row[1], 'inning': row[2], 'side': row[3],
                    'ord': row[4], 'text': row[5], 'pitches': row[6]})
    connection.close()
    return pbp


def copy_expert(table_string, data_type, file_header, data):
    """
    Copy data to the database using a csv file as an intermediary.
    :param table_string: the table to copy to, including column names if applicable in the format
    table_name(column1, column2)
    :param data_type: the type of the data, such as 'conferences' or 'box_score_hitting' to create
    and copy
    :param file_header: the header of the csv file
    :param data: the data to copy that will be inserted into the csv file via a csv dictwriter.
    This data must be a list of dicts
    :return: None
    """
    
    copy_file_name = FileUtils.get_copy_file_name(data_type)
    with open(copy_file_name, 'wb') as copy_file:
        writer = unicodecsv.DictWriter(copy_file, file_header)
        writer.writeheader()
        writer.writerows(data)
        copy_file.flush()
    
    connection = connect()
    
    cursor = connection.cursor()
    
    cursor.copy_expert("COPY {table_string} from STDIN delimiter ',' NULL AS '' "
                       "CSV HEADER".format(table_string=table_string), open(copy_file_name))
    connection.commit()
    
    connection.close()


def create_team(year, school_ncaa_id):
    """
    Insert a team that is not already in the database, usually from a school that is NAIA.This
    method gives the team a generic conference called 'Other', which will be changed if a
    matching team is scraped and added later.
    :param year: the year of this team
    :param school_ncaa_id: the ncaa id of the school
    :return: the id of the newly created team
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT id '
                   'FROM school '
                   'WHERE ncaa_id = {ncaa_id}'.format(ncaa_id=school_ncaa_id))
    school_id = cursor.fetchone()[0]
    cursor.execute('INSERT INTO team(year, conference_id, school_id) '
                   'VALUES({year}, {conference_id}, {school_id}) '
                   'RETURNING id;'.format(year=year, conference_id=get_default_conference_id(),
                                          school_id=school_id))
    team_id = cursor.fetchone()[0]

    connection.commit()

    connection.close()
    return team_id


def get_player_year_stats(year, division, stat_type):
    """
    Get player year total stats for the specified type.
    :param year: the year of the stats
    :param division: the division of the stats
    :param stat_type: the type of stats ('hitting', 'pitching', 'fielding')
    :return: an array of dicts, with the dicts being comprised of a mapping of the stat headers
    to the stat values, ordered by roster id in ascending order
    """
    connection = connect()
    cursor = connection.cursor()
    headers = {'hitting': ['ab, ', 'h, ', 'dbl, ', 'tpl, ', 'hr, ', 'bb, ', 'ibb, ', 'hbp, ', 'r, ',
                           'rbi, ', 'k, ', 'sf, ', 'sh, ', 'dp, ', 'sb, ', 'cs'],
               'pitching': ['app, ', 'gs, ', 'ord, ', 'w, ', 'l, ', 'sv, ', 'ip, ', 'p, ', 'bf, ',
                            'h, ', 'dbl, ', 'tpl, ', 'hr, ', 'bb, ', 'ibb, ', 'hbp, ', 'r, ',
                            'er, ', 'ir, ', 'irs, ', 'fo, ', 'go, ', 'k, ', 'kl, ', 'sf, ', 'sh, ',
                            'bk, ', 'wp, ', 'cg, ', 'sho'],
               'fielding': ['po, ', 'a, ', 'e, ', 'pb, ', 'ci, ', 'sb, ', 'cs, ', 'dp, ', 'tp']}
    select_string = 'stats.'.join(headers[stat_type])
    cursor.execute('SELECT r.id, {select_string} '
                   'FROM player_year_totals_{stat_type}({year}, {division}) AS stats '
                   '   JOIN roster AS r ON r.id = stats.roster_id '
                   'ORDER BY r.id ASC'
                   .format(select_string=select_string, stat_type=stat_type, year=year,
                           division=division))
    stat_rows = []
    for row in cursor:
        stats = {'roster_id': row[0]}
        for index, heading in enumerate(headers[stat_type]):
            stats[heading.replace(', ', '')] = row[1 + index]
        stat_rows.append(stats)
    connection.close()
    return stat_rows


def get_roster_id(year, division, first_name, last_name, school_name):
    """
    Get a player's roster id from their first name and last name. Could possibly return the wrong
    player, since names are not unique, but it is unlikely that two players with the same first
    name and last name would be on the same team.
    :param year: the year of the player
    :param division: the division the player played in
    :param first_name: the first name of the player
    :param last_name: the last name of the player
    :param school_name: the school the player played at
    :return: the player id of the player or None if the player is not found or if more than one
    player is found
    """
    
    connection = connect()
    cursor = connection.cursor()
    
    cursor.execute('SELECT r.id '
                   'FROM roster AS r '
                   '  JOIN team AS t ON t.id = r.team_id '
                   '  JOIN player AS p ON p.id = r.player_id '
                   '  JOIN school AS s ON s.id = t.school_id '
                   '  JOIN conference AS c ON c.id = t.conference_id '
                   'WHERE p.first_name = %s '
                   '  AND p.last_name = %s '
                   '  AND t.year = %s '
                   '  AND c.division = %s '
                   '  AND s.name = %s;', (first_name, last_name, year, division, school_name))
    player_ids = cursor.fetchmany(2)
    connection.close()
    if len(player_ids) != 1:
        return None
    return player_ids[0][0]


def get_year_division_game_ids(year, division):
    """
    Get all game ids from this year and division.
    :param year: the year of the games
    :param division: the division of the games
    :return: a list of game ids
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game.id '
                   'FROM game '
                   '  JOIN team AS at ON at.id = game.away_team_id '
                   '  JOIN team AS ht ON ht.id = game.home_team_id '
                   '  JOIN conference AS ac ON ac.id = at.conference_id '
                   '  JOIN conference AS hc ON hc.id = ht.conference_id '
                   'WHERE at.year = %s '
                   '  AND (ac.division = %s '
                   '  OR hc.division = %s)'
                   'ORDER BY game.id', [year, division, division])
    return [row[0] for row in cursor]


def get_game_lineup(game_id, side):
    """
    Get the lineup for the specified side team for this game.
    :param game_id: the game id of the game
    :param side: the side(away or home) of the lineup
    :return: a list of player dicts: {(first_name, last_name): roster_id}
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT game_id, roster_id, first_name, last_name '
                   'FROM hitting_line '
                   '  JOIN game ON game.id = hitting_line.game_id '
                   '  JOIN roster ON roster.id = hitting_line.roster_id '
                   '  JOIN player ON player.id = roster.player_id '
                   'WHERE game_id = %s '
                   '  AND roster.team_id = game.{}_team_id'.format(side), [game_id])
    lineup = []
    for row in cursor:
        lineup.append({(row[2], row[3]): row[1]})
    
    connection.close()
    
    return lineup


def get_game_pbp(game_id):
    """
    Get the play by play for the specified game.
    :param game_id: the game id of the game
    :return: a list of play by play dicts, in order by inning, side, then ord
    """
    connection = connect()
    cursor = connection.cursor()
    cursor.execute('SELECT team_id, inning, side, ord, text, pitches '
                   'FROM play_by_play AS pbp '
                   'WHERE game_id = %s '
                   'ORDER BY inning, side, ord', [game_id])
    pbp = []
    for row in cursor:
        pbp.append({'team_id': row[0], 'inning': row[1], 'side': row[2],
                    'ord': row[3], 'text': row[4], 'pitches': row[5]})
    return pbp
